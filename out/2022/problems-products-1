<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Problems with products, part one</title><link rel="icon" href=""><link href="https://fonts.googleapis.com/css?family=Inconsolata|Merriweather" rel="stylesheet"><link rel="stylesheet" type="text/css" href="../hash/85a636ccc52703eb9b8e8a4508a0cc49.css"><meta name="twitter:site:id" content="18271443"><meta name="twitter:title" content="Problems with products, part one"></head><body><header class="global-page-header"><div class="container"><a href="..">Chris Martin</a></div></header><main><div><div class="post-head container"><h1 class="post-title">Problems with products, part one</h1><div class="post-date">2022 November 17</div></div><div class="post-body"><div class="container"><p><i>You can find this article as a literate Haskell file <a href="../hash/ec3616fda641b44782af3aecf13f5dbf.lhs">here</a>.</i></p><p>Where we see a type parameter to the right of a function arrow (or with no arrow
at all, since <code>a</code> is isomorphic to <code>() -&gt; a</code>), we have a covariant functor (or
simply, &quot;functor&quot;).</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">newtype</span> <span class="dt">Decode</span> k v a <span class="fu">=</span> <span class="dt">Decode</span>{<span class="ot"> decode ::</span> <span class="dt">Map</span> k v <span class="ot">-&gt;</span> a }</code></pre></div><div class="container"><p>Covariant functors quite often admit an <i>applicative</i> aspect that allows us to
build up larger stuff within the type parameter.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">(★)<span class="ot"> ::</span> <span class="dt">Decode</span> k v a <span class="ot">-&gt;</span> <span class="dt">Decode</span> k v b <span class="ot">-&gt;</span> <span class="dt">Decode</span> k v (a, b)</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">at ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Decode</span> k <span class="dt">Char</span> <span class="dt">Char</span>
at k <span class="fu">=</span> <span class="dt">Decode</span> (Map.findWithDefault <span class="ch">&#39;\0&#39;</span> k)</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">abc ::</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Char</span>
abc <span class="fu">=</span> [(<span class="dv">1</span>, <span class="ch">&#39;a&#39;</span>), (<span class="dv">2</span>, <span class="ch">&#39;b&#39;</span>), (<span class="dv">3</span>, <span class="ch">&#39;c&#39;</span>)]</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">(abc <span class="fu">&amp;</span> decode (at <span class="dv">1</span> ★ at <span class="dv">2</span>))  <span class="fu">==</span>  (<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>)</code></pre></div><div class="container"><p>To define <code>(★)</code> is left as an exercise for the reader; it is a good exercise for
anyone who does not already immediately know how. The particularly
Haskell-savvy, however, will likely choose to use a derived <code>Applicative</code>
instance.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">deriving</span> <span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Decode</span> k v)
<span class="kw">deriving</span> <span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Decode</span> k v)</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">(★) <span class="fu">=</span> liftA2 (,)</code></pre></div><div class="container"><p>The two-tuple only takes us so far, and sooner or later (but probably sooner, if
we&#39;re not just playing around) we&#39;ll want to start working with larger products.
More than two things. <code>(★)</code> can be nested. (I knew this ahead of time, which is
why I named it as an infix operator.)</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">(abc <span class="fu">&amp;</span> decode (at <span class="dv">1</span> ★ at <span class="dv">2</span>))           <span class="fu">==</span>  (<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>)
(abc <span class="fu">&amp;</span> decode ((at <span class="dv">1</span> ★ at <span class="dv">2</span>) ★ at <span class="dv">3</span>))  <span class="fu">==</span>  ((<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>), <span class="ch">&#39;c&#39;</span>)
(abc <span class="fu">&amp;</span> decode (at <span class="dv">1</span> ★ (at <span class="dv">2</span> ★ at <span class="dv">3</span>)))  <span class="fu">==</span>  (<span class="ch">&#39;a&#39;</span>, (<span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span>))</code></pre></div><div class="container"><p>This, of course, sucks, because nobody wants nested tuples like that. You want a
three-tuple, right? Thus enters the real clever trick of the <code>Applicative</code>
class.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">(abc <span class="fu">&amp;</span> decode (pure (,,) <span class="fu">&lt;*&gt;</span> at <span class="dv">1</span> <span class="fu">&lt;*&gt;</span> at <span class="dv">2</span> <span class="fu">&lt;*&gt;</span> at <span class="dv">3</span>))
    <span class="fu">==</span> (<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span>)</code></pre></div><div class="container"><p>Better than tuples, even, we can use types that are more meaningful to us.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">data</span> <span class="dt">XYZ</span> a <span class="fu">=</span> <span class="dt">XYZ</span>{<span class="ot"> x ::</span> a,<span class="ot"> y ::</span> a,<span class="ot"> z ::</span> a } <span class="kw">deriving</span> <span class="dt">Eq</span></code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">decodeXYZ ::</span> <span class="dt">Decode</span> <span class="dt">Int</span> <span class="dt">Char</span> (<span class="dt">XYZ</span> <span class="dt">Char</span>)
decodeXYZ <span class="fu">=</span> pure <span class="dt">XYZ</span> <span class="fu">&lt;*&gt;</span> at <span class="dv">1</span> <span class="fu">&lt;*&gt;</span> at <span class="dv">2</span> <span class="fu">&lt;*&gt;</span> at <span class="dv">3</span></code></pre></div><div class="container"><p>And we can use <code>do</code> and record sugar to forget about field order.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">decodeXYZ&#39; <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> at <span class="dv">1</span>; y <span class="ot">&lt;-</span> at <span class="dv">2</span>; z <span class="ot">&lt;-</span> at <span class="dv">3</span>; pure <span class="dt">XYZ</span>{ x, y, z }</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">decodeXYZ&#39;&#39; <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> at <span class="dv">1</span>; z <span class="ot">&lt;-</span> at <span class="dv">3</span>; y <span class="ot">&lt;-</span> at <span class="dv">2</span>; pure <span class="dt">XYZ</span>{ x, y, z }</code></pre></div><div class="container"><p>And it is, I think, fair to call it a trick. Because, for one thing, history
implies that this approach wasn&#39;t obvious; I&#39;ve seen nothing predating
<i>Applicative Programming with Effects</i> which seems to have started circulating
in 2005, the class appears in GHC&#39;s <code>base</code> library starting in 2006, and
<code>ApplicativeDo</code> doesn&#39;t hit the compiler until 2016.</p><p>And for another thing, it&#39;s sort of weird. Consider the types of the subterms:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">pure (,,)<span class="ot">                   ::</span> <span class="dt">Decode</span> <span class="dt">Int</span> <span class="dt">Char</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> (<span class="dt">Char</span>, <span class="dt">Char</span>, <span class="dt">Char</span>))
pure (,,) <span class="fu">&lt;*&gt;</span> at <span class="dv">0</span><span class="ot">          ::</span> <span class="dt">Decode</span> <span class="dt">Int</span> <span class="dt">Char</span> (        <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> (<span class="dt">Char</span>, <span class="dt">Char</span>, <span class="dt">Char</span>))
pure (,,) <span class="fu">&lt;*&gt;</span> at <span class="dv">0</span> <span class="fu">&lt;*&gt;</span> at <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Decode</span> <span class="dt">Int</span> <span class="dt">Char</span> (                <span class="dt">Char</span> <span class="ot">-&gt;</span> (<span class="dt">Char</span>, <span class="dt">Char</span>, <span class="dt">Char</span>))</code></pre></div><div class="container"><p>The idea that we have a <code>Decode</code> that represents a parser which produces a
result of type <code>Char -&gt; (Char, Char, Char)</code> is, frankly, not even what I&#39;m
thinking about when I write an applicative expression. It is only something I
think about when I&#39;m explaining why it works. To me this is enough to place any
technique squarely in the category of clever trick.</p><p>The final reason I call applicative programming a trick is that when we step
outside of covariant functors, we find that <code>Applicative</code> is no longer
applicable. (Indeed the superclass constraint said this already.)</p><hr><p>Just like we encode a product of values such as <code>XYZ</code> from an input map, so too
may we be interested in the reverse: turning a record into a <code>Map</code> by turning
each field into a <code>Map</code> and merging all the results together.</p><p>(This is not so contrived a topic. The problem posed here is one encountered
whenever we encode and write process environment variables, HTTP headers, JSON
objects, and so on.)</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">newtype</span> <span class="dt">Encode</span> k v a <span class="fu">=</span> <span class="dt">Encode</span>{<span class="ot"> encode ::</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> k v }</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">to ::</span> k <span class="ot">-&gt;</span> <span class="dt">Encode</span> k v v
to k <span class="fu">=</span> <span class="dt">Encode</span> \v <span class="ot">-&gt;</span> Map.singleton k v</code></pre></div><div class="container"><p>The <code>to</code> function can construct an <code>Encode</code> definition suitable for each of the
three fields <code>x</code>, <code>y</code>, <code>z</code> of the <code>XYZ</code> record.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">(<span class="ch">&#39;a&#39;</span> <span class="fu">&amp;</span> encode (to <span class="dv">1</span>))  <span class="fu">==</span>  [(<span class="dv">1</span>, <span class="ch">&#39;a&#39;</span>)]
(<span class="ch">&#39;b&#39;</span> <span class="fu">&amp;</span> encode (to <span class="dv">2</span>))  <span class="fu">==</span>  [(<span class="dv">2</span>, <span class="ch">&#39;b&#39;</span>)]
(<span class="ch">&#39;c&#39;</span> <span class="fu">&amp;</span> encode (to <span class="dv">3</span>))  <span class="fu">==</span>  [(<span class="dv">3</span>, <span class="ch">&#39;c&#39;</span>)]</code></pre></div><div class="container"><p>We can define a 2-tuple combination, much like we did for <code>Decode</code>.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">(★★)<span class="ot"> ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Encode</span> k v a <span class="ot">-&gt;</span> <span class="dt">Encode</span> k v b <span class="ot">-&gt;</span> <span class="dt">Encode</span> k v (a, b)
encodeA ★★ encodeB <span class="fu">=</span> <span class="dt">Encode</span> \(a, b) <span class="ot">-&gt;</span>
    (a <span class="fu">&amp;</span> encode encodeA) <span class="fu">&lt;&gt;</span>
    (b <span class="fu">&amp;</span> encode encodeB)</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">((<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>) <span class="fu">&amp;</span> encode (to <span class="dv">1</span> ★★ to <span class="dv">2</span>))  <span class="fu">==</span>  [(<span class="dv">1</span>, <span class="ch">&#39;a&#39;</span>), (<span class="dv">2</span>, <span class="ch">&#39;b&#39;</span>)]</code></pre></div><div class="container"><p>And we can define an <code>Encode</code> for <code>XYZ</code>.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">encodeXYZ ::</span> <span class="dt">Encode</span> <span class="dt">Int</span> a (<span class="dt">XYZ</span> a)
encodeXYZ <span class="fu">=</span> <span class="dt">Encode</span> \xyz <span class="ot">-&gt;</span>
    (x xyz <span class="fu">&amp;</span> encode (to <span class="dv">1</span>)) <span class="fu">&lt;&gt;</span>
    (y xyz <span class="fu">&amp;</span> encode (to <span class="dv">2</span>)) <span class="fu">&lt;&gt;</span>
    (z xyz <span class="fu">&amp;</span> encode (to <span class="dv">3</span>))</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">(<span class="dt">XYZ</span>{ x <span class="fu">=</span> <span class="ch">&#39;a&#39;</span>, y <span class="fu">=</span> <span class="ch">&#39;b&#39;</span>, z <span class="fu">=</span> <span class="ch">&#39;c&#39;</span> } <span class="fu">&amp;</span> encode encodeXYZ)
    <span class="fu">==</span> [(<span class="dv">1</span>, <span class="ch">&#39;a&#39;</span>), (<span class="dv">2</span>, <span class="ch">&#39;b&#39;</span>), (<span class="dv">3</span>, <span class="ch">&#39;c&#39;</span>)]</code></pre></div><div class="container"><p>What we don&#39;t have is a combinator that works directly on <code>Encode</code> like <code>&lt;*&gt;</code>
does for <code>Decode</code>. This may seem like an unimportant quibble, since <code>encodeXYZ</code>
was not particularly difficult to define, but it ends up compounding into a
bigger practical problems.</p><p>There is also one other concern of more obvious practical relevance:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">encodeXYZ&#39; <span class="fu">=</span> <span class="dt">Encode</span> \xyz <span class="ot">-&gt;</span>
    (x xyz <span class="fu">&amp;</span> encode (to <span class="dv">1</span>)) <span class="fu">&lt;&gt;</span>
    (z xyz <span class="fu">&amp;</span> encode (to <span class="dv">3</span>))</code></pre></div><div class="container"><p>If we accidentally neglect to encode one of the fields in the applicative-do
<code>Decode</code> expression, the compiler emits a warning. If we omit an <code>Encode</code> step,
as in <code>encodeXYZ&#39;</code> above, the mistake goes unremarked upon.</p><hr><p>When a type variable appears in both a covariant and a contravariant way, we
have an <i>invariant</i> functor. The contravariant aspect prohibits defining <code>fmap</code>,
and the covariant aspect prohibits defining <code>contramap</code>.</p><p>This happens, for example, when we bundle <code>Decode</code> and <code>Encode</code> together into one
type, which seems like a reasonable thing to want to do:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">data</span> <span class="dt">Codec</span> k v a <span class="fu">=</span> <span class="dt">Codec</span>{<span class="ot"> co ::</span> <span class="dt">Encode</span> k v a,<span class="ot"> dec ::</span> <span class="dt">Decode</span> k v a }</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">key ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Codec</span> k <span class="dt">Char</span> <span class="dt">Char</span>
key k <span class="fu">=</span> <span class="dt">Codec</span>{ co <span class="fu">=</span> to k, dec <span class="fu">=</span> at k }</code></pre></div><div class="container"><p>We can concoct combinations for invariant functors of products.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">(★★★)<span class="ot"> ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Codec</span> k v a <span class="ot">-&gt;</span> <span class="dt">Codec</span> k v b <span class="ot">-&gt;</span> <span class="dt">Codec</span> k v (a, b)
formatA ★★★ formatB <span class="fu">=</span> <span class="dt">Codec</span>
    { dec <span class="fu">=</span> dec formatA ★ dec formatB
    , co <span class="fu">=</span> co formatA ★★ co formatB
    }</code></pre></div><div class="container"><p>Exercise: Define <code>Format Int Char XYZ</code> in terms of <code>key 1</code>, <code>key 2</code>, and <code>key 3</code>.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">codecXYZ <span class="fu">=</span> <span class="dt">Codec</span>{ co <span class="fu">=</span> undefined, dec <span class="fu">=</span> undefined }</code></pre></div><div class="container"><p>It isn&#39;t terribly difficult, but it isn&#39;t terribly easy either. What you have to
do is write the <code>Decode</code> and the <code>Encode</code> separately. They don&#39;t compose in
parallel. It&#39;s up to you to make sure they&#39;re defined harmoniously. It&#39;s all
terribly inconvenient.</p><p>Part two, if I am able to finish it, will be about solutions.</p></div></div></div></main><div class="post-footer container"><p>I write about Haskell and related topics; you can find my works online on <a href="http://typeclasses.com">Type Classes</a> and in print from <a href="http://joyofhaskell.com"><span style="text-decoration: italic;">The Joy of Haskell</span></a>.</p></div></body></html>