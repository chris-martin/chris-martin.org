<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Problems with products, part 2</title><link rel="icon" href=""><link href="https://fonts.googleapis.com/css?family=Inconsolata|Merriweather" rel="stylesheet"><link rel="stylesheet" type="text/css" href="../hash/85a636ccc52703eb9b8e8a4508a0cc49.css"><meta name="twitter:site:id" content="18271443"><meta name="twitter:title" content="Problems with products, part 2"></head><body><header class="global-page-header"><div class="container"><a href="..">Chris Martin</a></div></header><main><div><div class="post-head container"><h1 class="post-title">Problems with products, part 2</h1><div class="post-date">2022 November 18</div></div><div class="post-body"><div class="container"><p><i>You can find this article as a literate Haskell file <a href="../hash/a7942db58e6798563749789da9179a0e.lhs">here</a>.</i></p><p>Definitions carried over from part one:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">newtype</span> <span class="dt">Decode</span> k v a <span class="fu">=</span> <span class="dt">Decode</span>{<span class="ot"> decode ::</span> <span class="dt">Map</span> k v <span class="ot">-&gt;</span> a }
<span class="kw">newtype</span> <span class="dt">Encode</span> k v a <span class="fu">=</span> <span class="dt">Encode</span>{<span class="ot"> encode ::</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> k v }
<span class="kw">data</span> <span class="dt">Codec</span> k v a <span class="fu">=</span> <span class="dt">Codec</span>{<span class="ot"> co ::</span> <span class="dt">Encode</span> k v a,<span class="ot"> dec ::</span> <span class="dt">Decode</span> k v a }</code></pre></div><div class="container"><p>I first saw the following technique used with <code>optparse-applicative</code>, though I
cannot remember where. Here is a typical-looking type that might represent the
values of all a program&#39;s command-line arguments:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">data</span> <span class="dt">Opt1</span> <span class="fu">=</span> <span class="dt">Opt1</span>{<span class="ot"> verbose ::</span> <span class="dt">Bool</span>,
<span class="ot">                  file    ::</span> FilePath,
<span class="ot">                  jobs    ::</span> <span class="dt">Natural</span> }</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">opt1 <span class="fu">=</span> <span class="dt">Opt1</span>{ verbose <span class="fu">=</span> <span class="dt">True</span>, file <span class="fu">=</span> <span class="st">&quot;/tmp/xyz.hs&quot;</span>, jobs <span class="fu">=</span> <span class="dv">4</span> }</code></pre></div><div class="container"><p>Suppose we wrap each of the three fields in the <code>Identity</code> constructor. This, of
course, achieves nothing, apart from giving us something to refer to when we
think about the alteration that follows.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">data</span> <span class="dt">Opt2</span> <span class="fu">=</span> <span class="dt">Opt2</span>{<span class="ot"> verbose ::</span> <span class="dt">Identity</span> <span class="dt">Bool</span>,
<span class="ot">                  file    ::</span> <span class="dt">Identity</span> FilePath,
<span class="ot">                  jobs    ::</span> <span class="dt">Identity</span> <span class="dt">Natural</span> }</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">opt2 <span class="fu">=</span> <span class="dt">Opt2</span>{ verbose <span class="fu">=</span> <span class="dt">Identity</span> <span class="dt">True</span>,
             file    <span class="fu">=</span> <span class="dt">Identity</span> <span class="st">&quot;/tmp/xyz.hs&quot;</span>,
             jobs    <span class="fu">=</span> <span class="dt">Identity</span> <span class="dv">4</span> }</code></pre></div><div class="container"><p>Now instead of <code>Identity</code>, we&#39;ll make that a type parameter <code>f</code>.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">data</span> <span class="dt">Opt3</span> f <span class="fu">=</span> <span class="dt">Opt3</span>{<span class="ot"> verbose ::</span> f <span class="dt">Bool</span>,
<span class="ot">                    file    ::</span> f FilePath,
<span class="ot">                    jobs    ::</span> f <span class="dt">Natural</span> }</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">opt3 <span class="fu">=</span> <span class="dt">Opt3</span>{ verbose <span class="fu">=</span> <span class="dt">Identity</span> <span class="dt">True</span>,
             file    <span class="fu">=</span> <span class="dt">Identity</span> <span class="st">&quot;/tmp/xyz.hs&quot;</span>,
             jobs    <span class="fu">=</span> <span class="dt">Identity</span> <span class="dv">4</span> }</code></pre></div><div class="container"><p>Notice that still apparently we&#39;ve done very little. The definition of <code>opt3</code> is
exactly like that of <code>opt2</code>, only now its type is <code>Opt3 Identity</code> rather than
<code>Opt2</code>. But what this shift has done is now let us use type constructors other
than just <code>Identity</code>. For example, <code>Opt.Parser</code>:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">opt3Parser ::</span> <span class="dt">Opt3</span> <span class="dt">Opt.Parser</span>
opt3Parser <span class="fu">=</span>
  <span class="dt">Opt3</span>{ verbose <span class="fu">=</span> Opt.switch (Opt.short <span class="ch">&#39;v&#39;</span>),
        file    <span class="fu">=</span> Opt.strOption (Opt.short <span class="ch">&#39;f&#39;</span>),
        jobs    <span class="fu">=</span> Opt.option Opt.auto (Opt.short <span class="ch">&#39;j&#39;</span>) }</code></pre></div><div class="container"><p>Whereas <code>Opt3 Identity</code> consists of three values -- <code>Bool</code>, <code>FilePath</code>, and
<code>Natural</code> -- <code>Opt3 Opt.Parser</code> consists of three parsers: an <code>Opt.Parser Bool</code>,
an <code>Opt.Parser FilePath</code>, and an <code>Opt.Parser Natural</code>.</p><p>The question is then how to use such a thing, because I do not want three
parsers; I want them combined into one parser that shall have <code>Opt3 Identity</code> as
its result type.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">multiplyParser ::</span> <span class="dt">Opt3</span> <span class="dt">Opt.Parser</span> <span class="ot">-&gt;</span> <span class="dt">Opt.Parser</span> (<span class="dt">Opt3</span> <span class="dt">Identity</span>)
multiplyParser <span class="fu">=</span> undefined</code></pre></div><div class="container"><p>However, it now feels like we have made some progress, because we can at least
<i>express</i> the composition of parsers (in a way that generalizes to contravariant
and invariant functors), even if we do not yet have to means to evaluate the
expression.</p><p>The parsing example may seem superfluous because <code>Opt.Parser</code> is already
<code>Applicative</code>, and so there is little need to improve upon the faculties for
composition that it already has. But notice that we can insert other types of
<code>f</code> as well, including invariant functors such as <code>Codec k v</code> that do not admit
<code>Applicative</code> composition.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">opt3Codec ::</span> <span class="dt">Opt3</span> (<span class="dt">Codec</span> <span class="dt">Char</span> <span class="dt">String</span>)
opt3Codec <span class="fu">=</span> <span class="dt">Opt3</span>{ verbose <span class="fu">=</span> verboseCodec, file <span class="fu">=</span> fileCodec, jobs <span class="fu">=</span> jobsCodec }</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">verboseCodec <span class="fu">=</span> charStringCodec <span class="ch">&#39;v&#39;</span> (<span class="dt">Iso</span> show (<span class="fu">==</span> <span class="st">&quot;True&quot;</span>))</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">fileCodec <span class="fu">=</span> charStringCodec <span class="ch">&#39;f&#39;</span> (<span class="dt">Iso</span> id id)</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">jobsCodec <span class="fu">=</span> charStringCodec <span class="ch">&#39;k&#39;</span> (<span class="dt">Iso</span> show (fromMaybe <span class="dv">0</span> <span class="fu">.</span> readMaybe))</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">data</span> <span class="dt">Iso</span> a b <span class="fu">=</span> <span class="dt">Iso</span> (a <span class="ot">-&gt;</span> b) (b <span class="ot">-&gt;</span> a)</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">charStringCodec ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Iso</span> a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Codec</span> <span class="dt">Char</span> <span class="dt">String</span> a
charStringCodec k (<span class="dt">Iso</span> encodeString decodeString) <span class="fu">=</span>
    <span class="dt">Codec</span>{ co <span class="fu">=</span> <span class="dt">Encode</span> \v <span class="ot">-&gt;</span> Map.singleton k (encodeString v),
           dec <span class="fu">=</span> <span class="dt">Decode</span> \m <span class="ot">-&gt;</span> decodeString (Map.findWithDefault <span class="st">&quot;&quot;</span> k m) }</code></pre></div><div class="container"><p>Again, now we have a way to express the product of three codecs, but we are
still missing a function to multiply these three factors into a single codec.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">multiplyCodec ::</span> <span class="dt">Opt3</span> (<span class="dt">Codec</span> k v) <span class="ot">-&gt;</span> <span class="dt">Codec</span> k v (<span class="dt">Opt3</span> <span class="dt">Identity</span>)
multiplyCodec <span class="fu">=</span> undefined</code></pre></div><div class="container"><hr><p>The next time I saw higher-kinded products was Oliver Charles presenting the
<code>rel8</code> library, which includes a neat trick that I will include now. This
business of having to insert the <code>Identity</code> data constructor into each field
expression when we changed from <code>Opt1</code> to <code>Opt2 Identity</code> is a bit irksome. The
trick lets us eliminate it.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">type</span> <span class="dt">Factor</span><span class="ot"> ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
<span class="kw">type</span> family <span class="dt">Factor</span> f a <span class="kw">where</span>
    <span class="dt">Factor</span> <span class="dt">Identity</span> a <span class="fu">=</span> a
    <span class="dt">Factor</span> f        a <span class="fu">=</span> f a</code></pre></div><div class="container"></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">data</span> <span class="dt">Opt4</span> f <span class="fu">=</span> <span class="dt">Opt4</span>{<span class="ot"> verbose ::</span> <span class="dt">Factor</span> f <span class="dt">Bool</span>,
<span class="ot">                    file    ::</span> <span class="dt">Factor</span> f FilePath,
<span class="ot">                    jobs    ::</span> <span class="dt">Factor</span> f <span class="dt">Natural</span> }</code></pre></div><div class="container"><p>The family instance <code>Factor Identity a = a</code> provides a special handling of the
case where <code>f = Identity</code>, stating that this is merely an alias for <code>a</code> itself.
The second instance, <code>Factor f a = f a</code>, says that for all other <code>f</code>,
<code>Factor f a</code> should be read as simply <code>f a</code>, which is what we had before.</p><p>Values of <code>Opt4 Identity</code> can now be written without an <code>Identity</code> term, exactly
as we wrote <code>opt1</code>.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">opt4 ::</span> <span class="dt">Opt4</span> <span class="dt">Identity</span>
opt4 <span class="fu">=</span> <span class="dt">Opt4</span>{ verbose <span class="fu">=</span> <span class="dt">True</span>, file <span class="fu">=</span> <span class="st">&quot;/tmp/xyz.hs&quot;</span>, jobs <span class="fu">=</span> <span class="dv">4</span> }</code></pre></div><div class="container"><p>And the codec definitions for <code>Opt3</code> and <code>Opt4</code> are the same.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">opt4Codec ::</span> <span class="dt">Opt4</span> (<span class="dt">Codec</span> <span class="dt">Char</span> <span class="dt">String</span>)
opt4Codec <span class="fu">=</span> <span class="dt">Opt4</span>{ verbose <span class="fu">=</span> verboseCodec, file <span class="fu">=</span> fileCodec, jobs <span class="fu">=</span> jobsCodec }</code></pre></div><div class="container"><hr><p>Now we must return to how to define the two &quot;multiply&quot; functions.</p><ul><li><code>Opt4 Opt.Parser -&gt; Opt.Parser (Opt4 Identity)</code></li><li><code>Opt4 (Codec k v) -&gt; Codec k v (Opt4 Identity)</code></li></ul><p>More generally, something that looks like:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">multiply ::</span> forall (<span class="ot"> factors ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> )
                   (<span class="ot"> functor ::</span>  <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>          )<span class="fu">.</span>
            factors functor <span class="ot">-&gt;</span> functor (factors <span class="dt">Identity</span>)
multiply <span class="fu">=</span> undefined</code></pre></div><div class="container"><p>In our latter example, the <code>factors</code> are <code>Opt4</code> (representing the three option
factors <code>verbose</code>, <code>file</code>, and <code>jobs</code>) and the <code>functor</code> is <code>Codec k v</code>.</p><p>But that&#39;s a job for another day.</p></div></div></div></main><div class="post-footer container"><p>I write about Haskell and related topics; you can find my works online on <a href="http://typeclasses.com">Type Classes</a> and in print from <a href="http://joyofhaskell.com"><span style="text-decoration: italic;">The Joy of Haskell</span></a>.</p></div></body></html>