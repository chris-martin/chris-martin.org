<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Line wrap</title><link rel="icon" href=""><link href="https://fonts.googleapis.com/css?family=Inconsolata|Merriweather" rel="stylesheet"><link rel="stylesheet" type="text/css" href="../hash/85a636ccc52703eb9b8e8a4508a0cc49.css"><meta name="twitter:site:id" content="18271443"><meta name="twitter:title" content="Line wrap"></head><body><header class="global-page-header"><div class="container"><a href="..">Chris Martin</a></div></header><main><div><div class="post-head container"><h1 class="post-title">Line wrap</h1><div class="post-date">2017 December 15</div></div><div class="post-body"><div class="container"><p>Last night I let myself be driven to anger by some old <a href="https://thecleancoder.blogspot.ca/2010/10/craftsman-62-dark-path.html">Uncle Bob</a> writing, and I had to write a retort.</p><ol><li><p>This &quot;TDD&quot; process involves intentionally writing code that is wrong. Maybe this is supposed to be a way to overcome writer&#39;s block, I don&#39;t know, but I cannot be convinced that the path to correctness is anything other than writing correct code at every step of the way. I know that it&#39;s extremely popular to make broken things and then fix them, but I believe we can do so much better.</p></li><li><p>The solution fails to break the problem into smaller, more understandable pieces. This is the source of Alphonse&#39;s difficulty in writing accurate tests; they are trying to think about too many things at once.</p></li></ol><h2>Composition-driven design</h2><p>Write down the type of the thing you&#39;re trying to define.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">wrap ::</span> <span class="dt">Natural</span>  <span class="co">-- column</span>
     <span class="ot">-&gt;</span> <span class="dt">Text</span>     <span class="co">-- input</span>
     <span class="ot">-&gt;</span> <span class="dt">Text</span></code></pre></div><div class="container"><p><code>wrap column input</code> will produce <code>input</code> with line breaks inserted so that no
line is longer than <code>column</code>, preferring to break lines at word boundaries.</p><p>Consider whether there is anything we can do to break the problem into smaller pieces that can be solved separately. There&#39;s a useful observation we can make here: The way that one line is wrapped doesn&#39;t affect the way another line is wrapped. So we can break the input into its component lines, wrap each line, and then put the result back together. This seems like a quite clean reduction from our original problem to an easier one.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">wrap column <span class="fu">=</span>
  splitOn <span class="st">&quot;\n&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  fmap (wrapOneLine column) <span class="fu">&gt;&gt;&gt;</span>
  intercalate <span class="st">&quot;\n&quot;</span>

<span class="ot">wrapOneLine ::</span> <span class="dt">Natural</span>  <span class="co">-- column</span>
            <span class="ot">-&gt;</span> <span class="dt">Text</span>     <span class="co">-- input</span>
            <span class="ot">-&gt;</span> <span class="dt">Text</span></code></pre></div><div class="container"><p><code>wrapOneLine</code> is the same as <code>wrap</code>, but the <code>input</code> argument may not contain any line breaks.</p><p>Is there another way to further subdivide the input? We should probably try splitting it on word boundaries, since the word boundary positions are the only aspect of the string&#39;s structure that we care about.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">tokenize ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]</code></pre></div><div class="container"><p>A place where we&#39;re comfortable inserting a line break is a place that is either before or after a space (or both; breaking between two spaces seems acceptable).</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">tokenize <span class="fu">=</span> groupBy
  (\x y <span class="ot">-&gt;</span> not (isSpace x <span class="fu">||</span> isSpace y))</code></pre></div><div class="container"><p>It isn&#39;t entirely obvious to me that what we just wrote is correct, so let&#39;s test it:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="fu">&gt;&gt;&gt;</span> tokenize <span class="st">&quot;abc def  gh&quot;</span>
[<span class="st">&quot;abc&quot;</span>,<span class="st">&quot; &quot;</span>,<span class="st">&quot;def&quot;</span>,<span class="st">&quot; &quot;</span>,<span class="st">&quot; &quot;</span>,<span class="st">&quot;gh&quot;</span>]</code></pre></div><div class="container"><p>Looks good. Notice how each space character is its own separate token, even where there were two spaces in a row, because it&#39;s fine to insert a line break at any point among a group of contiguous spaces.</p><p>Now I think we&#39;re going to need a function that packs as many tokens as possible into one line. We&#39;ll refer to the result of this operation as a &quot;packing,&quot; which consists of the line we constructed and the remaining tokens that we didn&#39;t use.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="kw">type</span> <span class="dt">Packing</span> <span class="fu">=</span>
  ( <span class="dt">Text</span>    <span class="co">-- tokens packed into a line</span>
  , [<span class="dt">Text</span>]  <span class="co">-- remaining tokens that didn&#39;t fit</span>
  )

pack<span class="ot"> ::</span> <span class="dt">Natural</span>        <span class="co">-- column</span>
     <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> <span class="dt">Text</span>  <span class="co">-- tokens</span>
     <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Packing</span></code></pre></div><div class="container"><p><code>pack column tokens</code> is the concatenation of as many tokens as possible without exceeding <code>column</code> characters, and a list of the remaining unconsumed tokens. If it is not possible to pack <i>any</i> tokens, this will evaluate to <code>Nothing</code>.</p><p>To implement this, let&#39;s start by writing a function that enumerates <i>all</i> of the ways to pack tokens, regardless of maximum column length.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">packings ::</span> <span class="dt">NonEmpty</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Packing</span>]
packings tokens <span class="fu">=</span> f (empty, toList tokens)
  <span class="kw">where</span>
<span class="ot">    f ::</span> <span class="dt">Packing</span> <span class="ot">-&gt;</span> [<span class="dt">Packing</span>]
    f (_, []) <span class="fu">=</span> []
    f (packed, nextToken <span class="fu">:</span> remainingTokens) <span class="fu">=</span>
      packing <span class="fu">:</span> f packing
      <span class="kw">where</span>
        packing <span class="fu">=</span> ( append packed nextToken
                  , remainingTokens )</code></pre></div><div class="container"><p>Again this is probably something that we need to test to make sure what we just wrote makes sense.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="fu">&gt;&gt;&gt;</span> packings [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>]
[(<span class="st">&quot;a&quot;</span>,[<span class="st">&quot;b&quot;</span>]),(<span class="st">&quot;ab&quot;</span>,[])]</code></pre></div><div class="container"><p>Now let&#39;s implement <code>pack</code> by selecting, among the possible packings, the longest one that fits within the column length.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">pack column <span class="fu">=</span> packings <span class="fu">&gt;&gt;&gt;</span> foldr f <span class="dt">Nothing</span>
  <span class="kw">where</span>
<span class="ot">    f ::</span> <span class="dt">Packing</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Packing</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Packing</span>
    f x<span class="fu">@</span>(packed, _) <span class="dt">Nothing</span>
      <span class="fu">|</span> fromIntegral (length packed) <span class="fu">&lt;=</span> column <span class="fu">=</span> <span class="dt">Just</span> x
    f _ y <span class="fu">=</span> y</code></pre></div><div class="container"><p>This one calls for a whole battery of tests, to cover all of the cases.</p><p>Where <i>all</i> of the tokens fit onto the line:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="fu">&gt;&gt;&gt;</span> pack <span class="dv">3</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bb&quot;</span>]
<span class="dt">Just</span> (<span class="st">&quot;abb&quot;</span>,[])</code></pre></div><div class="container"><p>Where <i>not all</i> of the tokens fit onto the line:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="fu">&gt;&gt;&gt;</span> pack <span class="dv">4</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bb&quot;</span>, <span class="st">&quot;cc&quot;</span>]
<span class="dt">Just</span> (<span class="st">&quot;abb&quot;</span>,[<span class="st">&quot;cc&quot;</span>])</code></pre></div><div class="container"><p>Where <i>no</i> tokens fit onto the line:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="fu">&gt;&gt;&gt;</span> pack <span class="dv">2</span> [<span class="st">&quot;abc&quot;</span>]
<span class="dt">Nothing</span></code></pre></div><div class="container"><p>In the last case, we&#39;re allowed to resort to breaking a token. So let&#39;s write a variant of the <code>pack</code> function that breaks a token if necessary, thus <i>always</i> giving us a packing (hence we have eliminated the <code>Maybe</code> from the result type).</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">pack&#39; ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Packing</span>
pack&#39; column tokens<span class="fu">@</span>(firstToken <span class="fu">:|</span> remainingTokens) <span class="fu">=</span>
  pack column tokens <span class="fu">&amp;</span> fromMaybe break
  <span class="kw">where</span>
    break <span class="fu">=</span> splitAt (fromIntegral column) firstToken
      <span class="fu">&amp;</span> fmap (<span class="fu">:</span> remainingTokens)</code></pre></div><div class="container"><p>I&#39;m pretty sure we don&#39;t need to test all of the conditions we tested for <code>pack</code>, so let&#39;s just check the token-breaking aspect that <code>pack&#39;</code> introduced.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="fu">&gt;&gt;&gt;</span> pack&#39; <span class="dv">2</span> [<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;d&quot;</span>]
(<span class="st">&quot;ab&quot;</span>,[<span class="st">&quot;c&quot;</span>,<span class="st">&quot;d&quot;</span>])</code></pre></div><div class="container"><p>Now that we know how to pack a single line full of as many tokens as it can hold, we can do that recursively to fill a bunch of lines.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">wrapTokens ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
wrapTokens column tokens <span class="fu">=</span>
  <span class="kw">case</span> nonEmpty tokens <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []
    <span class="dt">Just</span> tokens&#39; <span class="ot">-&gt;</span>
      <span class="kw">let</span> (line, moreTokens) <span class="fu">=</span> pack&#39; column tokens&#39;
      <span class="kw">in</span>  line <span class="fu">:</span> wrapTokens column moreTokens</code></pre></div><div class="container"><p>Let&#39;s just reuse the same test cases we used for <code>pack</code>.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="fu">&gt;&gt;&gt;</span> wrapTokens <span class="dv">3</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bb&quot;</span>]
[<span class="st">&quot;abb&quot;</span>]

<span class="fu">&gt;&gt;&gt;</span> wrapTokens <span class="dv">4</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bb&quot;</span>, <span class="st">&quot;cc&quot;</span>]
[<span class="st">&quot;abb&quot;</span>,<span class="st">&quot;cc&quot;</span>]

<span class="fu">&gt;&gt;&gt;</span> wrapTokens <span class="dv">2</span> [<span class="st">&quot;abc&quot;</span>]
[<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;c&quot;</span>]</code></pre></div><div class="container"><p>Now we have enough components finished to finally get back to implementing <code>wrapOneLine</code>. We&#39;ll split the line into tokens, group the tokens into lines, and then glue the lines together with a newline character.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">wrapOneLine column <span class="fu">=</span>
  tokenize <span class="fu">&gt;&gt;&gt;</span>
  wrapTokens column <span class="fu">&gt;&gt;&gt;</span>
  intercalate <span class="st">&quot;\n&quot;</span></code></pre></div><div class="container"><p>So now... what were we doing here? Oh yeah, the <code>wrap</code> function. It ought to work now.</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="fu">&gt;&gt;&gt;</span> wrap <span class="dv">3</span> <span class="st">&quot;one two three&quot;</span>
<span class="st">&quot;one\n \ntwo\n \nthr\nee&quot;</span>

<span class="fu">&gt;&gt;&gt;</span> wrap <span class="dv">4</span> <span class="st">&quot;one two three&quot;</span>
<span class="st">&quot;one \ntwo \nthre\ne&quot;</span>

<span class="fu">&gt;&gt;&gt;</span> wrap <span class="dv">5</span> <span class="st">&quot;one two three&quot;</span>
<span class="st">&quot;one \ntwo \nthree&quot;</span>

<span class="fu">&gt;&gt;&gt;</span> wrap <span class="dv">5</span> <span class="st">&quot;one   two three&quot;</span>
<span class="st">&quot;one  \n two \nthree&quot;</span></code></pre></div><div class="container"><p>And it does.</p><h2>Reflection</h2><p>I tried to let this post fairly accurately represent my thought process; the ordering reflects the order in which I wrote the code. A few observations:</p><ol><li><p>I write functions before writing tests. The process of implementation helps you know what sorts of test cases are worth checking, versus which things are pretty obviously right.</p></li><li><p>Sometimes I take a top-down approach: First write the function that combines the smaller pieces, and then implement the smaller pieces. Sometimes I take a bottom-up approach: First write small pieces that seem like they will be useful, and then figure out how to use them. I don&#39;t think either is necessarily more appropriate; I think you should start with whatever occurs to you first.</p></li><li><p>I proceeded in a very linear fashion. I didn&#39;t go back and rewrite anything, and I didn&#39;t do any whole-program debugging. Once each function was written and tested, it was done.</p></li><li><p>I defined seven top-level terms; Alphonse wrote only one, and at the end refactored it into two. It isn&#39;t apparent that more is better, but generally I find that to be the case. It signals a more granular breakdown of the problem, which corresponds to comprehensibility, testability, and generality.</p></li></ol><h2>Appendix</h2><p>For completeness, here is the full lists of extensions and imports I used:</p></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">{-# LANGUAGE OverloadedLists   #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Control.Arrow</span>      ((&gt;&gt;&gt;))
<span class="kw">import </span><span class="dt">Data.Bool</span>          (not, (||))
<span class="kw">import </span><span class="dt">Data.Char</span>          (isSpace)
<span class="kw">import </span><span class="dt">Data.Function</span>      ((&amp;))
<span class="kw">import </span><span class="dt">Data.Functor</span>       (fmap, ($&gt;))
<span class="kw">import </span><span class="dt">Data.List</span>          (foldr)
<span class="kw">import </span><span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span> (..), nonEmpty,
                           toList)
<span class="kw">import </span><span class="dt">Data.Maybe</span>         (<span class="dt">Maybe</span> (..), fromMaybe)
<span class="kw">import </span><span class="dt">Data.Ord</span>           ((&lt;=))
<span class="kw">import </span><span class="dt">Data.Text.Lazy</span>     (<span class="dt">Text</span>, append, empty,
                           groupBy, intercalate,
                           length, splitAt, splitOn)
<span class="kw">import </span><span class="dt">Numeric.Natural</span>    (<span class="dt">Natural</span>)
<span class="kw">import </span><span class="dt">Prelude</span>            (fromIntegral, undefined)</code></pre></div><div class="container"></div></div></div></main><div class="post-footer container"><p>I write about Haskell and related topics; you can find my works online on <a href="http://typeclasses.com">Type Classes</a> and in print from <a href="http://joyofhaskell.com"><span style="text-decoration: italic;">The Joy of Haskell</span></a>.</p></div></body></html>